#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<stack>


using namespace std;


struct Point {
    int row, col;
    
    bool operator!=(const Point& rhs) {
        if (this->row != rhs.row || this->col != rhs.col)
            return true;
        return false;
    }

};


int maze[4][5]{
{0,1,0,0,0},
{0,0,1,1,1},
{1,0,1,0,0},
{0,0,0,0,0}
};



Point getunvisitAdjacentnode(bool** mark, Point point, int m, int n)
{
    Point resP; resP.col = -1; resP.row = -1;
    if (point.row - 1 >= 0&& mark[point.row - 1][point.col] == 0) {
    
           resP.row = point.row - 1;
           resP.col = point.col;
           return  resP;
        
    }
    if (point.col + 1 < n&& mark[point.row][point.col + 1] == 0)
    {
      
            resP.row = point.row;
            resP.col = point.col + 1;
            return resP;
        
    }
    if (point.col -1 > 0&&mark[point.row][point.col - 1] == 0)
    {
            resP.row = point.row;
            resP.col = point.col - 1;
            return resP;
    
    }
    if (point.row +1 < m&&mark[point.row + 1][point.col] == 0) {
        
        
            resP.row = point.row + 1;
            resP.col = point.col;
            return resP;
        
    }




}



void mazePath(void* maze, int m, int n, const Point& startP, Point& endP, stack<Point>& pointStack)
{
    int** maze2d = new int* [m];
    for (int i = 0; i < m; i++)
    {
        maze2d[i] = (int*)maze + i * n;//copy the maze.
    }
    if (maze2d[startP.row][startP.col] == 1 || maze2d[endP.row][endP.col] == 1)
    {
        return;
    }
    bool** mark = new bool* [m];
    for (int i = 0; i < m; i++)
        mark[i] = new bool[n];
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            mark[i][j] = *((int*)maze + i * n + j);
        }
    
    }

    //stackpush:startpoint
    pointStack.push(startP);
    mark[startP.row][startP.col]= true;

    while (pointStack.empty()==false&&pointStack.top()!=endP)
    {
        Point adjacentunvisitnode = getunvisitAdjacentnode(mark, pointStack.top(), m, n);
        if(adjacentunvisitnode.row==-1)
        {
            pointStack.pop(); continue;//goback 
        }
        mark[adjacentunvisitnode.row][adjacentunvisitnode.col] = true;
        pointStack.push(adjacentunvisitnode);
    }

}




int main()
{
    Point startP; startP.row = 0; startP.col = 0;
    Point endP;
    endP.row = 3; endP.col = 4;
    stack<Point> pointStack;
    mazePath(maze, 4, 5, startP, endP, pointStack);
    if (pointStack.empty() == true) {
        cout << "no right path" << endl;
    }
    else {
        stack<Point> tmpStack;
        cout << "path:";
        while (pointStack.empty()==false)
        {
            tmpStack.push(pointStack.top());
            pointStack.pop();
        }
        while (!tmpStack.empty())
        {
            printf("(%d,%d)", tmpStack.top().row, tmpStack.top().col);
            tmpStack.pop();
        }
    }
}
